// Copyright (c) 2013 Zhen, LLC. http://zhen.io. All rights reserved.
// Use of this source code is governed by the Apache 2.0 license.

package bytebuffer

import (
	"bytes"
	"log"
	"testing"
)

var _ = log.Ldate

func TestErrDataExceedsMaxSize(t *testing.T) {
	b, err := New(10, 128)
	if err != nil {
		t.Fatal(err)
	}

	st := b.(*byteBuffer)

	src := make([]byte, 1000000)
	if _, err := st.Put(src, 0); err != ErrDataExceedsMaxSize {
		t.Fatal("Should have exited with ErrDataExceedsMaxSize, " + err.Error())
	}
}

func TestErrSlotSizeTooSmall(t *testing.T) {
	if _, err := New(1, 128); err != ErrSlotSizeTooSmall {
		t.Fatal("Should have exited with ErrSlotSizeTooSmall, " + err.Error())
	}
}

func TestErrNotPowerOfTwo(t *testing.T) {
	if _, err := New(2, 10); err != ErrNotPowerOfTwo {
		t.Fatal("Should have exited with ErrNotPowerOfTwo, " + err.Error())
	}
}

func TestPutNoWrap(t *testing.T) {
	b, err := New(4, 16)
	if err != nil {
		t.Fatal(err)
	}

	st := b.(*byteBuffer)

	data := []byte{1, 2, 3, 4}
	needed, err := st.SlotsNeeded(len(data))
	if err != nil {
		t.Fatal(err)
	}

	for i := int64(0); i < 10; i++ {
		st.Put(data, i*int64(needed))
	}

	//log.Printf("%#v\n", st.buffer)

	if !bytes.Equal(st.buffer, []byte{0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}) {
		t.Fatalf("bytes not the same")
	}
}

func TestPutWrap(t *testing.T) {
	b, err := New(4, 16)
	if err != nil {
		t.Fatal(err)
	}

	st := b.(*byteBuffer)

	data := []byte{1, 2, 3, 4, 5, 6, 7}
	needed, err := st.SlotsNeeded(len(data))
	if err != nil {
		t.Fatal(err)
	}

	for i := int64(0); i < 10; i++ {
		data[0] = byte(i)
		st.Put(data, i*int64(needed))
	}

	//log.Printf("%#v\n", st.buffer)

	if !bytes.Equal(st.buffer, []byte{0x7, 0x0, 0x8, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 0x7, 0x0, 0x9, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 0x7, 0x0, 0x2, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 0x7, 0x0, 0x3, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 0x7, 0x0, 0x4, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 0x7, 0x0, 0x5, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 0x7, 0x0, 0x6, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 0x7, 0x0, 0x7, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0}) {
		t.Fatalf("bytes not the same")
	}
}

func TestPutVariableSizeNoWrap(t *testing.T) {
	b, err := New(4, 16)
	if err != nil {
		t.Fatal(err)
	}

	st := b.(*byteBuffer)

	data := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}

	slot := 0
	for i := int64(0); i < 10; i++ {
		needed, err := st.SlotsNeeded(len(data[:i]))
		if err != nil {
			t.Fatal(err)
		}

		st.Put(data[:i], int64(slot))
		slot += needed
	}

	//log.Printf("%#v\n", st.buffer)

	if !bytes.Equal(st.buffer, []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x0, 0x1, 0x2, 0x0, 0x0, 0x3, 0x0, 0x1, 0x2, 0x3, 0x0, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 0x8, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x0, 0x0, 0x9, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}) {
		t.Fatalf("bytes not the same")
	}
}

func TestPutVariableSizeWrap(t *testing.T) {
	b, err := New(4, 16)
	if err != nil {
		t.Fatal(err)
	}

	st := b.(*byteBuffer)

	data := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}
	slot := 0

	for i := int64(0); i < 12; i++ {
		needed, err := st.SlotsNeeded(len(data[:i]))
		if err != nil {
			t.Fatal(err)
		}

		st.Put(data[:i], int64(slot))
		slot += needed
	}

	//log.Printf("%#v\n", st.buffer)

	if !bytes.Equal(st.buffer, []byte{0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0x0, 0x1, 0x2, 0x3, 0x0, 0x4, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 0x8, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x0, 0x0, 0x9, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0x0, 0xa, 0x0, 0x1, 0x2, 0x3, 0x4}) {
		t.Fatalf("bytes not the same")
	}
}

func TestReadNoWrap(t *testing.T) {
	b, err := New(4, 16)
	if err != nil {
		t.Fatal(err)
	}

	st := b.(*byteBuffer)

	data := []byte{1, 2, 3, 4, 5, 6}
	st.Put(data, 0)

	out, err := st.Get(0)
	if err != nil {
		t.Fatal(err)
	}

	if !bytes.Equal(out, []byte{0x1, 0x2, 0x3, 0x4, 0x5, 0x6}) {
		t.Fatalf("bytes not the same")
	}
}

func TestReadWrap(t *testing.T) {
	b, err := New(4, 16)
	if err != nil {
		t.Fatal(err)
	}

	st := b.(*byteBuffer)

	data := []byte{1, 2, 3, 4, 5, 6}
	st.Put(data, 15)

	out, err := st.Get(15)
	if err != nil {
		t.Fatal(err)
	}

	if !bytes.Equal(out, []byte{0x1, 0x2, 0x3, 0x4, 0x5, 0x6}) {
		t.Fatalf("bytes not the same")
	}
}

func TestReadMaxDataSize(t *testing.T) {
	b, err := New(10, 128)
	if err != nil {
		t.Fatal(err)
	}

	st := b.(*byteBuffer)

	st.buffer[0] = 255
	st.buffer[1] = 255

	_, err = st.Get(0)
	if err != ErrDataExceedsMaxSize {
		t.Fatal("Should have exited with ErrDataExceedsMaxSize, " + err.Error())
	}
}

func BenchmarkPut(b *testing.B) {
	buf, err := New(10, 128)
	if err != nil {
		b.Fatal(err)
	}

	st := buf.(*byteBuffer)

	for i := 0; i < b.N; i++ {
		st.Put([]byte{1, 2, 3, 4}, int64(i))
	}
}
